Η εφαρμογή πελάτη, γνωστή ως PiLock Client είναι μια Smartphone εφαρμογή (Smartphone App), κατασκευασμένη για Android Smartphones. Μπορεί να λειτουργήσει σε οποιαδήποτε συσκευή που διαθέτει έκδοση Android Kitkat (API Level 19) ή ανώτερη. Σύμφωνα με την διανομή αγοράς εκδόσεων Android\sucite{android_api_distribution} για την συγκεκριμένη έκδοση Android, καλύπτεται το 90\% των συσκευών που βρίσκονται αυτή την στιγμή στην αγορά, οπότε είναι ιδανική η συγκεκριμένη επιλογή έκδοσης. Η εφαρμογή Android είναι εξ'ολοκλήρου κατασκευασμένη στο Android Studio (βλ \fullref{sec:ides}), και χρησιμοποιεί για λογισμικό διαχείρησης εκδόσεων, όπως και το λογισμικό του εξυπηρετητή, το Git.

\section{Activities}
	Η εφαρμογή αποτελείται από διάφορα Activities. Ώς Activity ορίζεται μία μοναδική, στοχευμένη γραφική διεπαφή χρήστη από την οποία ο χρήστης μπορεί να συγκεντρώνεται σε μία συγκεκριμένη κατάσταση\sucite{android_ref_activity}. Στην τελευταία έκδοση του PiLock (\verb|0.3.1|), υπάρχουν συνολικά τέσσερα (4) Activities:

	\begin{itemize}
		\item \textbf{LoginActivity}: Το Activity υπεύθυνο για την εισαγωγή στοιχείων και σύνδεση του χρήστη στο σύστημα του PiLock. Μέσω αυτού υλοποιείται το 1ο στάδιο εξουσιοδότησης. Αποτελείται από 2 πεδία κειμένου που δέχονται το Username και το Password του χρήστη καθώς επίσης και ένα πλήκτρο, μέσω του οποίου γίνεται αποστολή των στοιχείων αυτών στον Server.
		\item \textbf{PINEntryActivity}: Activity, μέσω του οποίου ο χρήστης εισάγει το PIN του και στέλνει αιτήματα ξεκλειδώματος. Μέσω αυτού υλοποιείται το 2ο στάδιο εξουσιοδότητης. Αποτελείται από ένα πεδίο κειμένου στο οποίο ο χρήστης μπορεί να εισάγει το PIN του καθώς επίσης και ένα πλήκτρο με το οποίο γίνεται αποστολή των στοιχείων αυτών στον Server.
		\item \textbf{ChangePinActivity}: Υπεύθυνο για την αλλαγή PIN του χρήστη. Αποτελείται από 3 πεδία κειμένου στα οποία ο χρήστης μπορεί να εισάγει το παλιό του PIN, το νέο του PIN καθώς επίσης και το νέο του PIN για δεύτερη φορά για επιβεβαίωση. Τέλος, αποτελείται και από ένα πλήκτρο με το οποίο γίνεται αποστολή του αιτήματος αλλαγής PIN στον Server.
		\item \textbf{SettingsActivity}: Μαζί με το \verb|SettingsFragment|, αποτελούν την οθόνη "ρυθμίσεων" της εφαρμογής. Μέχρι και την τελευταία έκδοση της εφαρμογής, η οθόνη ρυθμίσεων χρησιμοποιείται προκειμένου να οριστεί η διεύθυνση του Server, κατά την πρώτη εκτέλεση της εφαρμογής. Σε μία επόμενη έκδοση της εφαρμογής, θα προστεθεί επιλογή να ορίζεται ο Server ως προσβάσιμος αποκλειστικά μέσω WiFi (βλ. \fullref{ch:future_expansion}).
	\end{itemize}

\section{Αιτήματα HTTPS}
	Όπως αναφέρθηκε προηγουμένως, όλες οι ανταλλαγές πληροφοριών ανάμεσα στην εφαρμογή και τον Server γίνονται χρησιμοποιόντας το πρωτόκολλο HTTPS. Προκειμένου να καταστεί εύχρηστο, δημιουργήθηκε μια βιβλιοθήκη αποτελούμενη από 5 κλάσεις και ένα enum, η οποία αναλαμβάνει την αποστολή και λήψη πληροφοριών προς και από τον Server.

	Η κύρια κλάση-γονέας (Superclass) λέγεται \verb|HttpsRequest|, και χρησιμοποιείται προκειμένου να κρατά τις πληροφορίες ενός οποιουδήποτε HTTPS αιτήματος, όπως για παράδειγμα την διεύθυνση του αποδοχέα, τις παραμέτρους, καθώς επίσης και τις πληροφορίες που λαμβάνονται αφότου εκτελεστεί το αίτημα, όπως τον κωδικό απάντησης, καθώς επίσης και την ίδια την απάντηση. Μέσα σε αυτή την κλάση ορίστηκε η εσωτερική κλάση \verb|RequestNotExecutedException|, η οποία αποτελεί κλάση εξαίρεσης και χρησιμοποιείται σε περίπτωση που ο χρήστης ζητήσει να λάβει τα δεδομένα της απάντησης πρωτού εκτελεστεί το αίτημα. Τέλος, ορίζεται και το \verb|HttpsRequestListener| interface, το οποίο καλείται όταν ολοκληρωθεί ένα αίτημα. Αυτό καθιστά εύκολη την άμεση αυτοματοποίηση διαδικασιών με την λήξη των αιτημάτων.	Η κλάση \verb|HttpsRequest| κληρονομείται από δύο κλάσεις γνωστές ως \verb|HttpsGET| και \verb|HttpsPOST|, υπεύθυνες για αποστολή αιτημάτων GET και POST, αντίστοιχα. 

	Η διαδικασία αποστολής των αιτημάτων αυτών είναι η εξής:

	\begin{enumerate}
		\item Δημιουργία αντικειμένου τύπου \verb|HttpsGET| ή \verb|HttpsPOST|. Στον κατασκευαστή (Constructor), δίνονται ως ορίσματα η διεύθυνση (URL) του παραλήπτη και (προαιρετικά) οι παράμετροι του αιτήματος, σε μορφή \verb|HashMap<String, String>|. Μέσω της κλάσης \verb|QueryBuilder|, γίνεται κτήσιμο του σώματος του αιτήματος, από τις δοσμένες παραμέτρους.
		\item Σε περίπτωση που χρειαστεί να εκτελεστεί κάποια ενέργεια με την λήξη του αιτήματος, πρέπει να γίνει ορισμός του Request Listener μέσω της μεθόδου \verb|setRequestListener(HttpsRequest.HttpsRequestListener listener)|. Στο σώμα του HttpRequestListener, θα πρέπει να γίνει υλοποίηση της μεθόδου \verb|onRequestCompleted()|. Μόλις λήξει το αίτημα, και κλείσει η σύνδεση, θα εκτελεστεί αυτή η μέθοδος.
		\item Κλήση της μεθόδου \verb|SendGET(Context c)| ή \verb|SendPOST(Context c)|, ανάλογα τον τύπο του αιτήματος.
		\item Μετά την ολοκλήρωση του αιτήματος, μπορούμε να κάνουμε ανάκτηση του κωδικού απόκρισης καθώς επίσης και την ίδια την απόκριση καλόντας την μέθοδο \verb|getResponseCode()| και \verb|getResponse()|. Είναι καλό να γίνεται έλεγχος του αιτήματος για σφάλμα χρησιμοποιόντας την μέθοδο \verb|hasError()|, ανάκτηση του σε περίπτωση που υπάρχει μέσω της μεθόδου \verb|getError()| και να γίνεται σύγκριση με τις τιμές του \verb|HttpsConnectionError| για να διαπιστωθεί ποιο είναι το σφάλμα. Να σημειωθεί οτι το enum \verb|HttpsConnectionError| συμβολίζει μόνο σφάλματα σύνδεσης, και όχι σφάλματα μέσα στην ίδια την απόκριση. Για να γίνει διάγνωση της ίδιας της απόκρισης καλό είναι να γίνεται ανάκτηση και σύγκριση του κωδικού απάντησης με τους ήδη γνωστούς κωδικούς απάντησης του πρωτόκολλου HTTP (HTTP Response Codes).
		\item Αφότου γίνει ανάκτηση της απόκρισης, μπορεί να αναλυθεί μέσω της βιβλιοθήκης αποκωδικοποίησης JSON της Java.
	\end{enumerate}

	\subsection{Το πρόβλημα με τα Αυτο-Υπογεγραμμένα Πιστοποιητικά SSL}
		Ένα από τα δυσκολότερα προβλήματα που συναντήθηκαν κατά την πρώτη φάση υλοποίησης του PiLock ήταν η χρήση πιστοποιητικών SSL. Πολλές φορές, οι εγκαταστάσεις του PiLock θα χρησιμοποιούνται σε τοπικό επίπεδο (προσβάσιμες αποκλειστικά μέσω WiFi), πράγμα το οποίο καθιστά την απόκτηση πιστοποιητικού από μία εγκεκριμένη αρχή πιστοποίησης δαπανηρή και πολλές φορές αδύνατη. Για αυτό τον λόγο χρησιμοποιούνται αυτο-υπογεγραμμένα πιστοποιητικά SSL (Self Signed Certificates). Λόγο της δομής του, το σύστημα Android εμπιστεύεται πιστοποιητικά μόνο από έγκυρες αρχές πιστοποίησης, αλλά μπορεί να ρυθμιστεί, εφόσον το επιθυμεί ο προγραμματιστής, να εμπιστεύεται πιστοποιητικά από τρίτους. 

		Ο τρόπος ο οποίος επινοήθηκε προκειμένου να μπορεί να γίνει χρήση αυτο-υπογεγραμμένου πιστοποιητικού είναι ο εξής: Αφότου ο χρήστης δημιουργήσει το πιστοποιητικό για την εγκατάσταση του PiLock και το εγκαταστήσει, θα πρέπει να γίνει αντιγραφή του πιστοποιητικού (όχι του μυστικού κλειδιού) στον αρχικό κατάλογο στον χώρο αποθήκευσης του SmartPhone, σε ένα αρχείο με όνομα \verb|pilock.crt|, και σε μορφή PEM. Έπειτα, κατά την αποστολή αιτημάτων HTTPS, γίνεται ανάκτηση του συγκεκριμένου αρχείου από την κλάση \verb|CustomSSLTruster| και ορίζεται ως άξιο εμπιστοσύνης στο αίτημα. Για να γίνει ανάκτηση του πιστοποιητικού από τον χώρο αποθήκευσης του Smartphone χρειάζεται να δωθεί η άδεια πρόσβασης στον χώρο αποθήκευσης από τον χρήστη, κατά την διάρκεια εκτέλεσης του PiLock.

		Αυτό, εκτός από το να βοηθά στην λειτουργία του συστήματος, καθιστά ασφαλή την αποστολή αιτημάτων αποφεύγοντας επιθέσεις προσωποποίησης (Impersonation Attack), καθώς γίνεται σύγκριση του πιστοποιητικού του Server με αυτό που έχει αποθέσει ο χρήστης στην κάρτα μνήμης, και η σύνδεση απορρίπτεται αν δεν ταιριάζουν τα πιστοποιητικά.

\section{Μηχανισμός Heartbeat}
	Όπως αναφέρθηκε προηγουμένως (βλ. \fullref{sec:heartbeat}), έχει υλοποιηθεί στον Server μηχανισμός Heartbeat, υπεύθυνος για την αναφορά της κατάστασης του Server καθώς επίσης και για την επιβεβαίωση ενημερωμένης εφαρμογής. Ο μηχανισμός Heartbeat έχει υλοποιηθεί στην εφαρμογή πελάτη με την ομόνυμη κλάση \verb|Heartbeat|, η οποία διαθέτει όλες τις αναγκαίες μεθόδους για την λήψη της κατάστασης του Server, καθώς επίσης και ένα listener interface το οποίο είναι υπεύθυνο για εκτέλεση μεθόδων ανάλογα με το αποτέλεσμα του Heartbeat. 

	Το Heartbeat εκτελείται πριν να γίνει το οποιοδήποτε αίτημα προς τον Server και, αν ο Server δεν βρεθεί ή αν είναι κλειδωμένος, σταματά την διαδικασία του αιτήματος και δεν αποστέλλεται στον Server. Πιο συγκεκριμένα:
	\begin{enumerate}
		\item Γίνεται ανάγνωση του εσωτερικού χώρου αποθήκευσης του κινητού για την ύπαρξη αντιγράφου του πιστοποιητικού που χρησιμοποιεί ο Server. Αν δεν βρεθεί, το Heartbeat χαρακτηρίζεται ως αποτυχημένο.
		\item Στέλνεται αίτημα GET χωρίς παραμέτρους στην ρίζα (Root) της τοποθεσίας του PiLock Server. Αν δεν υπάρξει απάντηση, ή αν υπάρξει κάποιο πρόβλημα κατά την επικοινωνία, το Heartbeat χαρακτηρίζεται ως αποτυχημένο.
		\item Γίνεται ανάλυση της απόκρισης του Server. Για αρχή γίνεται έλεγχος του πεδίου κατάστασης (\verb|status|). Αν ο Server αναφέρει οτι είναι κλειδωμένος (\verb|LOCKED|), το Heartbeat χαρακτηρίζεται ως αποτυχημένο και εμφανίζεται μήνυμα κλειδωμένου Server στον χρήστη. 
		\item Αν ο Server αναφέρει οτι είναι "ζωντανός" (\verb|ALIVE|), ακολουθεί σύγκριση του πεδίου έκδοσης λογισμικού του Server, με μία προκαθορισμένη τιμή στον κώδικα της εφαρμογής (μεταβλητή \verb|LatestServerVersion|, κλάση \verb|VersionChecker|), που αναφέρει με ποια έκδοση Server είναι συμβατή η παρούσα έκδοση της εφαρμογής. Αν διαπιστώθεί οτι διαφέρουν (μέθοδος \verb|CheckVersion(VersionReportedByServer)|, κλάση \verb|VersionChecker|) το Heartbeat χαρακτηρίζεται ως αποτυχημένο και εμφανίζεται μήνυμα μη ενημερωμένης εφαρμογής στον χρήστη. 
		\item Αν δεν έχει μέχρι τώρα χαρακτηριστεί το Heartbeat ως αποτυχημένο, χαρακτηρίζεται ως επιτυχημένο και ολοκληρώνεται η εργασία.
	\end{enumerate}

	Παρομοίως με τα αιτήματα HTTPS, ο χρήστης πρέπει να ορίσει έναν listener για το Heartbeat. Συγκεκριμένα, πρέπει να υλοποιήσει 3 μεθόδους:

	\begin{itemize}
		\item \verb|onHeartbeatFinished()|: Εκτελείται με την λήξη του Heartbeat, ανεξάρτητα με το αποτέλεσμα.
		\item \verb|onHeartbeatSuccess()|: Εκτελείται έπειτα από την \verb|onHeartbeatFinished|, αν το Heartbeat ήταν επιτυχές.
		\item \verb|onHeartbeatFailure()|: Εκτελείται έπειτα από την \verb|onHeartbeatFinished|, αν το Heartbeat ήταν αποτυχημένο.
	\end{itemize}

\section{Κρυπτογράφηση Τεκμηρίων Πρόσβασης}
	Όπως αναφέρθηκε προηγουμένως, κατά το πρώτο στάδιο αυθεντικοποίησης μίας συσκευής με τον Server του PiLock, γίνεται αποστολή ενός τεκμηρίου πρόσβασης, γνωστό ως Authorization Token (Auth Token). Αυτό το τεκμήριο, στην περίπτωση που υποκλαπεί, η διαδικασία αυθεντικοποίησης θεωρείται μη ασφαλής. Υποκλοπή μπορεί να συμβεί σε περίπτωση που η εφαρμογή εγκαταστηθεί σε Rooted συσκευή Android. Σε τέτοιου είδους συσκευές, μία εφαρμογή μπορεί να αποκτήσει αυξημένα προνόμια πρόσβασης και να έχει πρόσβαση σε διάφορα στοιχεία, άλλων εφαρμογών ή του συστήματος, που κανονικά δεν θα είχε\sucite{android_secure_shared_preferences} (σε μια συσκευή χωρίς Root πρόσβαση). Εφόσον το τεκμήριο πρόσβασης αποθηκεύεται στα Shared Preferences της συσκευής, μια κακόβουλη εφαρμογή, σε περίπτωση που η συσκευή είναι Rooted, μπορεί να έχει πρόσβαση στα Shared Preferences άλλων εφαρμογών κατά βούληση. 

	Προκειμένου να καταστεί αδύνατον να γίνει ανάκτηση του τεκμήριου πρόσβασης από Rooted συσκευές, χρησιμοποιείται το σύστημα Android Keystore\sucite{android_keystore}. Για να γίνει η υλοποίησή του, δημιουργήθηκε η κλάση \verb|KeystoreHelper|, σκοπός της οποίας είναι να κρυπτογραφεί και να αποκρυπτογραφεί κάποιο δωσμένο αλφαριθμητικό μέσω του Android Keystore, χρησιμοποιόντας τον αλγόριθμο RSA. Αφότου δημιουργηθεί ένα αντικείμενο της κλάσης, οι μέθοδοι \verb|Encrypt(StringToEnc)| και \verb|Decrypt(Ciphertext)|, χρησιμοποιούνται για να γίνει κρυπτογράφηση ενός αλφαριθμητικού και αποκρυπτογράφηση αντίστοιχα. Συγκεκριμένα, γίνεται κρυπτογράφηση του Auth Token, και έπειτα γίνεται αποθήκευση του κρυπτογραφημένου Token στα Shared Preferences της συσκευής. Με αυτό τον τρόπο, καθίσταται ασφαλής η αποθήκευση ευαίσθητων δεδομένων της εφαρμογής.
